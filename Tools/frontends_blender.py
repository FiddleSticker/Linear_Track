
import os
import numpy as np


class ImageInterface:

    def __init__(self, directory):
        """
        A very basic class for performing ABA renewal experiments from static image input.
        It is assumed that the agent sees in every node of a topology graph a static 360deg image of the environment.
        Herein, rotation of the agent is not enabled. This setup accellerates standard ABA renewal experiments,
        since the Blender rendering 'overhead' is not reqired. It is necessary that Blender is run prior to the application of this class,
        since the interface assumes a worldStruct data block in the 'world' directory of the experiment folder.
        This data is generated by a initial run of the getWorldInformation.py script in the experiment folder.

        Parameters
        ----------
        directory :                         The directory containing all necessary files

        Returns
        ----------
        None
        """

        # retrieve all image information from the 'worldInfo' directory
        self._directory = directory
        self.images = np.load(os.path.join(self._directory, "images.npy"))

        # get the maximum safe zone dimensions for the robot to move in
        self.min_x, self.min_y, self.min_z, self.max_x, self.max_y, self.max_z = \
            np.load(os.path.join(self._directory, "safeZoneDimensions.npy"))
        self.safe_zone_vertices = np.load(os.path.join(self._directory, "safeZoneVertices.npy"))
        self.safe_zone_segments = np.load(os.path.join(self._directory, "safeZoneSegments.npy"))
        # initial robot pose
        self.robot_pose = np.array([0.0, 0.0, 1.0, 0.0])
        # stores the actual goal position (coordinates of the goal node)
        self.goal_position = None
        # indicator that flags arrival of the agent/robot at the actual goal node (this need NOT be the global goal node!)
        self.goal_reached = False
        # a dict that stores environmental information in each time step
        self.env_data = {'time': 0.0, 'pose': None, 'sensor': None, 'image': None}
        # this interface class requires a topologyModule
        self.topology_module = None

    def set_topology(self, topology_module):
        '''
        This function supplies the interface with a valid topology module.

        Parameters
        ----------
        topology_module :                   The topologyModule to be supplied.

        Returns
        ----------
        None
        '''
        self.topology_module = topology_module

    def get_manually_defined_topology_nodes(self) -> np.ndarray:
        '''
        This function reads all manually defined topology nodes from the environment (if such nodes are defined).

        Parameters
        ----------
        None

        Returns
        ----------
        topology_nodes :                    The list of manually defined topology nodes.
        '''
        return np.load(os.path.join(self._directory, "topologyNodes.npy"))

    def get_manually_defined_topology_edges(self) -> np.ndarray:
        '''
        This function reads all manually defined topology nodes from the environment (if such nodes are defined)

        Parameters
        ----------
        None

        Returns
        ----------
        topology_edges :                    The list of manually defined topology edges.
        '''
        return np.load(os.path.join(self._directory, "topologyEdges.npy"))

    def step_simulation_without_physics(self, x: float, y: float, yaw: float) -> (
    float, np.ndarray, np.ndarray, np.ndarray):
        '''
        This function propels the simulation. It uses teleportation to guide the agent/robot directly by means of global x, z, yaw values.

        Parameters
        ----------
        x :                                 The global x position to teleport to.
        z :                                 The global z position to teleport to.
        yaw :                               The global yaw value to teleport to.

        Returns
        ----------
        time_data :                         The time observation received from the simulation.
        pose_data :                         The pose observation received from the simulation.
        sensor_data :                       The sensor observation received from the simulation.
        image_data :                        The image observation received from the simulation.
        '''
        # update robot's/agent's pose
        self.robot_pose = np.array([x, y, yaw])
        # update environmental information
        # propel the simulation time by 1/100 of a second (standard time step)
        self.env_data['time'] += 0.01
        # the position can be updated instantaneously
        self.env_data['pose'] = np.array([x, y, np.cos(yaw / 180.0 * np.pi), np.sin(yaw / 180.0 * np.pi)])
        # there will be no need for sensor data in this interface class
        self.env_data['sensor'] = np.zeros(8)
        # the image data is read from the 'worldInfo' directory
        self.env_data['image'] = self.images[self.topology_module.next_node]

        return self.env_data['time'], self.env_data['pose'], self.env_data['sensor'], self.env_data['image']

    def actuate_robot(self, actuator_command: list) -> (float, np.ndarray, np.ndarray, np.ndarray):
        '''
        This function actually actuates the agent/robot in the virtual environment.

        Parameters
        ----------
        actuator_command :                  The command that is used in the actuation process.

        Returns
        ----------
        time_data :                         The time observation received from the simulation.
        pose_data :                         The pose observation received from the simulation.
        sensor_data :                       The sensor observation received from the simulation.
        image_data :                        The image observation received from the simulation.
        '''
        # if the actuator command has more than 2 array entries, this is a teleport command, and will cause a teleport jump of the agent/robot (no physics support)
        if actuator_command.shape[0] > 2:
            # call the teleportation routine
            time_data, pose_data, sensor_data, image_data = self.step_simulation_without_physics(actuator_command[0],
                                                                                                 actuator_command[1],
                                                                                                 actuator_command[2])
            # flag if the robot reached the goal (should always be the case after a teleportation)
            if self.goal_position is not None:
                if np.linalg.norm(pose_data[:2] - self.goal_position) < 0.01:
                    self.goal_reached = True
            return time_data, pose_data, sensor_data, image_data
        else:
            # otherwise, this is a standard motion command with physics support (the agent/robot approaches the goal by actuating the robot's/agent's wheels)
            time_data, pose_data, sensor_data, image_data = self.step_simulation(actuator_command[0],
                                                                                 actuator_command[1])
            # flag if the robot/agent reached the goal already
            if self.goal_position is not None:
                if np.linalg.norm(pose_data[:2] - self.goal_position) < 0.01:
                    self.goal_reached = True
            return time_data, pose_data, sensor_data, image_data

    def get_limits(self) -> np.ndarray:
        '''
        This function returns the limits of the environmental perimeter.

        Parameters
        ----------
        None

        Returns
        ----------
        limits :                            The limits of the environmental perimeter.
        '''
        return np.array([[self.min_x, self.max_x], [self.min_y, self.max_y]])

    def get_wall_graph(self) -> (list, list):
        '''
        This function returns the environmental perimeter by means of wall vertices/segments.

        Parameters
        ----------
        None

        Returns
        ----------
        walls_limits :                      The wall limits.
        perimeter_nodes :                   The perimeter nodes.
        '''
        return self.safe_zone_vertices, self.safe_zone_segments

    def stop_blender(self):
        pass

